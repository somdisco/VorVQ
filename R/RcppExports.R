# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Determine if two prototypes are Delaunay neighbors
#'
#' @param W prototype matrix, with prototype vectors in rows
#' @param iidx the first index of the neighbor pair to test
#' @param jidx the second index of the neighbor pair to test
#' @param lb a vector of the global (data range) lower bounds, by dimension
#' @param ub a vector of the global (data range) upper bounds, by dimension
#' @param verbose boolean, whether to display the LP solver status
#' @return 1 = prototypes iidx and jidx are neighbors, 0 = they are not
#' @details iidj and jidx should be valid row indices of W indexed from 1 (not 0). \cr
#' The global lower and upper bounds (xlb and xub) are needed to ensure the polyope definition is bounded.
#' Otherwise, the LP we need to solve here could be unbounded, which produces incorrect results.
#' 
#' @references
#' \insertRef{Delaunay1934}{VorVQ}
#' 
#' \insertRef{Agrell1993}{VorVQ}
#' @export
is_Delaunay_nhb <- function(W, iidx, jidx, lb, ub, verbose = TRUE) {
    .Call(`_VorVQ_is_Delaunay_nhb`, W, iidx, jidx, lb, ub, verbose)
}

#' Build the Delaunay Adjacency Matrix of a set of prototypes
#'
#' @param W prototype matrix, with prototype vectors in rows
#' @param lb a vector of the global (data range) lower bounds, by dimension
#' @param ub a vector of the global (data range) upper bounds, by dimension
#' @param parallel whether to process in parallel. Default = TRUE. 
#' @return A (binary, symmetric) adjacency matrix, nrows = ncols = nrow(W), giving
#' the Delaunay adjacencies between all prototypes in W. \cr
#' The global lower and upper bounds (xlb and xub) are needed to ensure the polyope definition is bounded.
#' Otherwise, the LP we need to solve here could be unbounded, which produces incorrect results.
#' 
#' @references
#' \insertRef{Delaunay1934}{VorVQ}
#' 
#' \insertRef{Agrell1993}{VorVQ}
#' @export
Delaunay_ADJ <- function(W, lb, ub, parallel = TRUE) {
    .Call(`_VorVQ_Delaunay_ADJ`, W, lb, ub, parallel)
}

#' Find Dikin ellipsoids inside a polytope
#' 
#' @description 
#' Returns a matrix E such that the ellipsoid \eqn{(y - c)'E^-1 (y - c) <= 1} is inscribed in the polytope defined by Ax <= b, 
#' with curvature influenced by the local geometry of the constraints at \eqn{c}
#' 
#' @param A LHS of polytope constraints
#' @param b RHS of polytope constraints
#' @param c interior point where Dikin ellipse is centered
#' @return the rotation matrix of the Dikin ellipsoid centered at \code{c}. 
#' 
#' 
#' @references 
#' \insertRef{Dikin1967}{VorVQ}
#' \insertRef{Boyd2004}{VorVQ}
#' @export 
Dikin_ell <- function(A, b, c) {
    .Call(`_VorVQ_Dikin_ell`, A, b, c)
}

#' Compute the Gabriel graph adjacency 
#' 
#' @param W the prototype matrix, prototype vectors in rows 
#' @param parallel boolean, whether to compute in parallel. Default = TRUE. 
#' 
#' @details 
#' The Gabriel graph is a proximity graph of points that is known to be a sub-graph 
#' of the Delaunay triangulation of the same set of points. 
#' 
#' @return a (binary, symmetric) adjacency matrix of dimension \code{nrow(W) x nrow(W)}.  Element 
#' \code{(i,j) = 1} IFF the prototype vectors \code{W[i,]} and \code{W[j,]} are Gabriel adjacent.  
#' Otherwise, entries are 0.  
#' 
#' @references
#' \insertRef{Gabriel1969}{VorVQ}
#' @export
Gabriel_ADJ <- function(W, parallel = TRUE) {
    .Call(`_VorVQ_Gabriel_ADJ`, W, parallel)
}

#' Max volume inscribed ellipsoid of polytope
#'
#' Returns the matrix E and vector c such that the ellipsoid \eqn{(y - c)'E^-1 (y - c) <= 1} is inscribed in the polytope defined by Ax <= b with maximum volume.
#' Code taken from Yin Zhang's \verb{MVE} routine.
#'
#' @param A matrix of LHS constraints in H-representation of polytope
#' @param b vector of RHS constraints in H-representation of polytope
#' @param c0 a point inside the polytope (not on the boundary)
#' @param maxiter integer number of iterations to perform, default = 100
#' @param tol tolerance for Zhang's MVE code, see paper, default = 1e-4
#' @param fix_c0 boolean, whether to fix the given center at c0 during iteration, default = F
#' @param verbose boolean, whether to display the solver status at each iteration, default = F
#' @return a list with components
#' \itemize{
#' \item{E}{a matrix defining the rotation and scale of the maximum volume ellipsoid}
#' \item{c}{a vector defining the center of the maximum volume ellipsoid}
#' \item{status}{a flag returned from Zhang's solver code.  See details.}
#' }
#' @details \verb{maxiter} and \verb{tol} are control (convergence) parameters
#' for Yin Zhang's \verb{MVE} routine.
#'
#' The polytope defined by A & b must be bounded.
#'
#' status = 0 indicates successful convergence; = -1 means maxiter was reached before convergence.
#'
#' @references 
#' \insertRef{ZhangGao2003}{VorVQ}
#' @export
max_vol_inscr_ell <- function(A, b, c0, maxiter = 100L, tol = 1e-4, fix_c0 = FALSE, verbose = FALSE) {
    .Call(`_VorVQ_max_vol_inscr_ell`, A, b, c0, maxiter, tol, fix_c0, verbose)
}

#' First Order Voronoi Cell Polytope
#' Returns the polytope definition Ax <= b of a single Voronoi cell
#' @param W matrix of prototypes in rows
#' @param iidx Index of Voronoi cell, 1-based.
#' @param DADJ (optional) - Delaunay adjacency. If used, the H-representation of the returned polytope will be tight, only including constraints from Delaunay neighbors.
#' @param lb (optional) - Global lower bound of data. If given, the H-representation of the returned polytope will include this as a lower bound.
#' @param ub (optional) - same as xlb, but for upper bounds. Both must be given in order for the global bounds to be appended to the polytope representation.
#' @param rmv_redundancies boolean, whether to check the system for redundancies, and remove any found 
#' @return a list with components A, b, cid
#' @export
vor1_polytope <- function(W, iidx, DADJ = NULL, lb = NULL, ub = NULL, rmv_redundancies = FALSE) {
    .Call(`_VorVQ_vor1_polytope`, W, iidx, DADJ, lb, ub, rmv_redundancies)
}

#' Second Order Voronoi Cell Polytope
#' Returns the polytope definition Ax <= b of a second order Voronoi cell
#' @param W matrix of prototypes in rows
#' @param DADJ Delaunay adjacency. The H-representation of the returned polytope will be tight, only including constraints from Delaunay neighbors.
#' @param iidx Index of 1st Voronoi cell
#' @param jidx Index of 2nd Voronoi cell
#' @param lb - Global lower bound of data. If given, the H-representation of the returned polytope will include this as a lower bound.
#' @param ub - same as xlb, but for upper bounds. Both must be given in order for the global bounds to be appended to the polytope representation.
#' @param rmv_redundancies boolean, whether to check the system for redundancies, and remove any found 
#' @return a list with components A, b, cid
#' @export
vor2_polytope <- function(W, iidx, jidx, DADJ = NULL, lb = NULL, ub = NULL, rmv_redundancies = FALSE) {
    .Call(`_VorVQ_vor2_polytope`, W, iidx, jidx, DADJ, lb, ub, rmv_redundancies)
}

#' Chebyshev center of a polytope
#'
#' @description 
#' For a feasible set of linear equations Ax<=b that define a bounded polytope P, 
#' the Chebyshev center is the center the largest inscribed ball contained in P.
#' Polytope definition should be given as Ax <= b. 
#'
#' @param A the LHS matrix of polytope constraints
#' @param b the RHS vector of polytope constraints 
#' @return a vector (of the same dimension as A) giving the interior point 
#' @export 
polytope_Chebyshev_center <- function(A, b) {
    .Call(`_VorVQ_polytope_Chebyshev_center`, A, b)
}

#' Check if point is interior
#' 
#' @description
#' For a feasible set of linear equations Ax<=b that define a bounded polytope P 
#' and a point x0, x0 is interior IFF b - Ax > 0.  
#' 
#' @param A the LHS matrix of polytope constraints
#' @param b the RHS vector of polytope constraints 
#' @param x the query point 
#' @return boolean = T if the query point satisfies the above condition 
#' @export 
is_interior_point <- function(A, b, x) {
    .Call(`_VorVQ_is_interior_point`, A, b, x)
}

