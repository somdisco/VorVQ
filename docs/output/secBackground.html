<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Chapter 1 Background | VorVQ</title>
  <meta name="description" content="Chapter 1 Background | VorVQ" />
  <meta name="generator" content="bookdown 0.20 and GitBook 2.6.7" />

  <meta property="og:title" content="Chapter 1 Background | VorVQ" />
  <meta property="og:type" content="book" />
  
  
  
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Chapter 1 Background | VorVQ" />
  
  
  

<meta name="author" content="Josh Taylor" />



  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="index.html"/>
<link rel="next" href="secInstallation.html"/>
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />









<script src="libs/accessible-code-block-0.0.1/empty-anchor.js"></script>


<style type="text/css">
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Preface</a></li>
<li class="chapter" data-level="1" data-path="secBackground.html"><a href="secBackground.html"><i class="fa fa-check"></i><b>1</b> Background</a><ul>
<li class="chapter" data-level="1.1" data-path="secBackground.html"><a href="secBackground.html#voronoi-tessellations"><i class="fa fa-check"></i><b>1.1</b> Voronoi Tessellations</a></li>
<li class="chapter" data-level="1.2" data-path="secBackground.html"><a href="secBackground.html#voronoi-half-plane-representations"><i class="fa fa-check"></i><b>1.2</b> Voronoi Half-Plane Representations</a></li>
<li class="chapter" data-level="1.3" data-path="secBackground.html"><a href="secBackground.html#chebyshev-centers"><i class="fa fa-check"></i><b>1.3</b> Chebyshev Centers</a></li>
<li class="chapter" data-level="1.4" data-path="secBackground.html"><a href="secBackground.html#prototype-proximity-graphs"><i class="fa fa-check"></i><b>1.4</b> Prototype Proximity Graphs</a></li>
<li class="chapter" data-level="1.5" data-path="secBackground.html"><a href="secBackground.html#secEllipsoids"><i class="fa fa-check"></i><b>1.5</b> Polytope Approximating Ellipsoids</a><ul>
<li class="chapter" data-level="1.5.1" data-path="secBackground.html"><a href="secBackground.html#dikin-ellipsoids"><i class="fa fa-check"></i><b>1.5.1</b> Dikin Ellipsoids</a></li>
<li class="chapter" data-level="1.5.2" data-path="secBackground.html"><a href="secBackground.html#maximum-volume-inscribed-ellipsoids"><i class="fa fa-check"></i><b>1.5.2</b> Maximum Volume Inscribed Ellipsoids</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="2" data-path="secInstallation.html"><a href="secInstallation.html"><i class="fa fa-check"></i><b>2</b> Installation</a></li>
<li class="chapter" data-level="3" data-path="a-complete-example.html"><a href="a-complete-example.html"><i class="fa fa-check"></i><b>3</b> A Complete Example</a><ul>
<li class="chapter" data-level="3.1" data-path="a-complete-example.html"><a href="a-complete-example.html#initialization"><i class="fa fa-check"></i><b>3.1</b> Initialization</a></li>
<li class="chapter" data-level="3.2" data-path="a-complete-example.html"><a href="a-complete-example.html#delaunay-adjacency"><i class="fa fa-check"></i><b>3.2</b> Delaunay Adjacency</a></li>
<li class="chapter" data-level="3.3" data-path="a-complete-example.html"><a href="a-complete-example.html#voronoi-polytope-definitions"><i class="fa fa-check"></i><b>3.3</b> Voronoi Polytope Definitions</a></li>
<li class="chapter" data-level="3.4" data-path="secBackground.html"><a href="secBackground.html#chebyshev-centers"><i class="fa fa-check"></i><b>3.4</b> Chebyshev Centers</a></li>
<li class="chapter" data-level="3.5" data-path="secBackground.html"><a href="secBackground.html#dikin-ellipsoids"><i class="fa fa-check"></i><b>3.5</b> Dikin Ellipsoids</a></li>
<li class="chapter" data-level="3.6" data-path="a-complete-example.html"><a href="a-complete-example.html#mvies"><i class="fa fa-check"></i><b>3.6</b> MVIEs</a></li>
<li class="chapter" data-level="3.7" data-path="a-complete-example.html"><a href="a-complete-example.html#visualizations"><i class="fa fa-check"></i><b>3.7</b> Visualizations</a></li>
<li class="chapter" data-level="3.8" data-path="a-complete-example.html"><a href="a-complete-example.html#saving-loading"><i class="fa fa-check"></i><b>3.8</b> Saving &amp; Loading</a></li>
<li class="chapter" data-level="3.9" data-path="a-complete-example.html"><a href="a-complete-example.html#performing-all-voronoi-calculations"><i class="fa fa-check"></i><b>3.9</b> Performing All Voronoi Calculations</a></li>
<li class="chapter" data-level="3.10" data-path="a-complete-example.html"><a href="a-complete-example.html#higher-dimensional-settings"><i class="fa fa-check"></i><b>3.10</b> Higher-Dimensional Settings</a></li>
</ul></li>
<li class="chapter" data-level="" data-path="references.html"><a href="references.html"><i class="fa fa-check"></i>References</a></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">VorVQ</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="secBackground" class="section level1">
<h1><span class="header-section-number">Chapter 1</span> Background</h1>
<div id="voronoi-tessellations" class="section level2">
<h2><span class="header-section-number">1.1</span> Voronoi Tessellations</h2>
<p>Vector quantization <span class="citation">[<a href="#ref-Gray1984" role="doc-biblioref">6</a>]</span> is a common task in data compression whereby data vectors <span class="math inline">\(x\)</span> are represented by a discrete set of <span class="math inline">\(n_W\)</span> <em>prototype</em> vectors <span class="math inline">\(W = \{w_j \in \mathbb{R}^d\}_{j=1}^{n_W}\)</span> according to some assignment rule <span class="math inline">\(j^* = BMU1(x)\)</span>, which returns the index <span class="math inline">\(j^*\)</span> of <span class="math inline">\(x\)</span>’s <strong>B</strong>est <strong>M</strong>atching <strong>U</strong>nit in <span class="math inline">\(W\)</span>. Likewise, an ancillary assignment rule <span class="math inline">\(k^* = BMU2(x)\)</span> returns the <em>second</em> Best Matching Unit to <span class="math inline">\(x\)</span> (again, from <span class="math inline">\(W\)</span>). The function <span class="math inline">\(BMU\)</span> can be any valid distance; here, we only consider the most common case where the BMU is selected via Euclidean distance:
<span class="math display">\[ j^* = BMU1(x) = \arg\min_j \, ||x - w_j||_2\]</span>
and
<span class="math display">\[ k^* = BMU2(x) = \arg\min_{k, k\neq j^*} \, ||x - w_k||_2.\]</span>
The region <span class="math inline">\(V_j \subset \mathbb{R}^d\)</span> for which <span class="math inline">\(j\)</span> is <span class="math inline">\(BMU1\)</span> is the <strong>first-order Voronoi cell</strong> generated by <span class="math inline">\(w_j\)</span>:
<span class="math display">\[ V_j = \{x \, : \, BMU1(x) = j \}\]</span>
The collection of cells <span class="math inline">\(\{V_j\}\)</span> <em>tessellates</em> (or tiles) <span class="math inline">\(\mathbb{R}^d\)</span> and is known as the <strong>first-order Voronoi tessellation</strong>. Similarly, the region <span class="math inline">\(V_{jk} \subset \mathbb{R}^d\)</span> for which <span class="math inline">\(j\)</span> is <span class="math inline">\(BMU1\)</span> and <span class="math inline">\(k\)</span> is <span class="math inline">\(BMU2\)</span> is the <strong>second-order Voronoi cell</strong> generated by the interaction of <span class="math inline">\(w_j\)</span> and <span class="math inline">\(w_k\)</span>:
<span class="math display">\[ V_{jk} = \{x \, : \, BMU1(x) = j \quad \&amp; \quad BMU2(x) = k\}.\]</span>
Again, the collection <span class="math inline">\(\{V_{jk}\}\)</span> produces a (different) tessellation of <span class="math inline">\(\mathbb{R}^d\)</span>. An example of the learned prototypes (black points) of synthetic two-dimensional data (gray points) and the induced first-order Voronoi tessellation (dashed lines) is given below:
<img src="figs/vor1_tess.png" width="70%" style="display: block; margin: auto;" /></p>
<p>One could, of course, extend this logic to produce higher-order (<span class="math inline">\(3,4,\ldots,n_W-1\)</span>) tessellations of <span class="math inline">\(\mathbb{R}^d\)</span> (see <span class="citation">[<a href="#ref-AtsuyukiEtAl2000" role="doc-biblioref">7</a>]</span> for further information on higher-order Voronoi tessellations). In <code>VorVQ</code> we only consider the first (Vor1) and second (Vor2) order cases, as they have been shown to faciliate manifold inference from learned vector quantizers (<span class="citation">[<a href="#ref-MartinetzSchulten1994" role="doc-biblioref">8</a>]</span>, <span class="citation">[<a href="#ref-TasdemirMerenyi2009" role="doc-biblioref">9</a>]</span>).</p>
</div>
<div id="voronoi-half-plane-representations" class="section level2">
<h2><span class="header-section-number">1.2</span> Voronoi Half-Plane Representations</h2>
<p>The definitions of each Vor1 and Vor2 cell above specify convex polyhedra in <span class="math inline">\(\mathbb{R}^d\)</span>. As such, each <span class="math inline">\(V_j\)</span> or <span class="math inline">\(V_{jk}\)</span> can be described geometrically using the half-plane representation <span class="citation">[<a href="#ref-Agrell1993" role="doc-biblioref">10</a>]</span> of their associated polyhedra, which is of the form <span class="math inline">\(Ax \leq b\)</span> for some coefficient matrix <span class="math inline">\(A\)</span> and upper bound vector <span class="math inline">\(b\)</span>. For example, transforming the Vor1 definition above to its half-plane representation is straightforward:
<span class="math display">\[\begin{align*} 
V_j &amp;= \{x \, : \, ||x - w_j||_2 \leq ||x - w_k||_2 \} \quad \forall \, k \neq j 
\\ &amp;= \{x \, : \, (w_k - w_j)^Tx \leq \frac{1}{2}(||w_k||_2^2 - ||w_j||_2^2) \} \quad \forall \, k \neq j 
\\ &amp;= \{x \, : \, A_j x \leq b_j \}
\end{align*}\]</span>
where <span class="math inline">\(A_j\)</span> is a <span class="math inline">\((n_W-1) \times d\)</span> matrix and <span class="math inline">\(b_j\)</span> is a <span class="math inline">\((n_W-1)\)</span> length vector. If global dimension-wise lower and upper bounds of the tessellated region are appended to the above system of inequalities then each Voronoi cell is guaranteed to be a closed polytope.</p>
<p>The form <span class="math inline">\(V_j = \{A_j x \leq b_j \}\)</span> is more amenable to performing optimization over each Voronoi cell. Various different objective functions, constrained to <span class="math inline">\(V_j\)</span>, give rise to most of the computation on offer by <code>VorVQ</code>.</p>
</div>
<div id="chebyshev-centers" class="section level2">
<h2><span class="header-section-number">1.3</span> Chebyshev Centers</h2>
<p>The computation of the ellipsoidal polytope approximators discussed in the <a href="secBackground.html#secEllipsoids">ellipsoid</a> section requires specifying an interior point to each Voronoi polytope. While Vor1 cells have a natural, known, interior point (the prototype <span class="math inline">\(w_j\)</span> which generates each cell), Vor2 cells do not. There are myriad ways of finding interior points in polytopes; <code>VorVQ</code> provides functionality to compute each Voronoi cell’s <a href="https://en.wikipedia.org/wiki/Chebyshev_center"><strong>Chebyshev center</strong></a>, which is a relatively lightweight method for generating an interior point as the center of the largest sphere which can be inscribed in the polytope. Formally, center <span class="math inline">\(c\)</span> is returned by the following linear program <span class="citation">[<a href="#ref-Boyd2004" role="doc-biblioref">1</a>]</span>:
<span class="math display">\[\begin{align*}
\text{maximize} &amp;\quad r
\\ \text{subject to:} &amp; 
\\ a_i^Tc + r ||a_i|| &amp;\leq b_i \, \forall \, i
\end{align*}\]</span>
where <span class="math inline">\(a_i\)</span> and <span class="math inline">\(b_i\)</span> are the <span class="math inline">\(i\)</span>-th row of <span class="math inline">\(A\)</span> and <span class="math inline">\(b\)</span> as previously defined. Note that the above LP is only bounded if <span class="math inline">\(Ax \leq b\)</span> represents a closed polytope, which is ensured by appending the global bounds of the tessellated region to the system of linear inequalities. A Voronoi polytope’s Chebyshev center (orange) is compared to its prototype location (black) for a two-dimensional Voronoi polytope below.
<img src="figs/poly_chebyshev.png" width="70%" style="display: block; margin: auto;" /></p>
</div>
<div id="prototype-proximity-graphs" class="section level2">
<h2><span class="header-section-number">1.4</span> Prototype Proximity Graphs</h2>
<p>In general, a proximity graph of a vector quantizer’s prototypes is a graph whose vertices are the prototypes and whose edges represent some type of neighbor relationship between prototypes. Probably the most famous proximity graph is the Delaunay triangulation <span class="citation">[<a href="#ref-Delaunay1934" role="doc-biblioref">2</a>]</span> which connects prototypes <span class="math inline">\(j\)</span> and <span class="math inline">\(k\)</span> if (and only if) their Voronoi cells <span class="math inline">\(V_j\)</span> and <span class="math inline">\(V_k\)</span> intersect (share a face) in <span class="math inline">\(\mathbb{R}^d\)</span>. Various methods exist to compute a Delaunay graph in low dimension (e.g., see the <a href="https://cran.r-project.org/web/packages/geometry/index.html"><code>geometry</code></a> package), but such methods typically involve storing a list of the vertices of the Delaunay “triangles” (simplexes, in higher dimension) and become infeasible as dimension grows. To avoid this bottleneck altogether <code>VorVQ</code> relies on the linear programming method of <span class="citation">[<a href="#ref-Agrell1993" role="doc-biblioref">10</a>]</span> to identify whether an edge exists between prototypes <span class="math inline">\(j\)</span> and <span class="math inline">\(k\)</span> in the Delaunay adjacency matrix, which we denote <span class="math inline">\(DADJ\)</span>. Briefly, recall that the linear system defining <span class="math inline">\(V_j\)</span> has components
<span class="math display">\[A = \left(
\begin{array}{c}
(w_1 - w_j)^T
\\ (w_2 - w_j)^T
\\ \vdots
\\ (w_{j-1} - w_j)^T
\\ (w_{j+1} - w_j)^T
\\ \vdots
\\ (w_{n_W} - w_j)^T
\end{array}
\right)
\qquad 
b = \frac{1}{2} \times \left(
\begin{array}{c}
||w_1||^2 - ||w_j||^2
\\ ||w_2||^2 - ||w_j||^2
\\ \vdots
\\ ||w_{j-1}||^2 - ||w_j||^2
\\ ||w_{j+1}||^2 - ||w_j||^2
\\ \vdots
\\ ||w_{n_W}||^2 - ||w_j||^2
\end{array}
\right)
\]</span>
Let <span class="math inline">\(a_k^T\)</span> denote the the row of <span class="math inline">\(A\)</span> involving <span class="math inline">\(w_j\)</span> and <span class="math inline">\(w_k\)</span>, and note that, if <span class="math inline">\(V_j\)</span> and <span class="math inline">\(V_k\)</span> share a face, <span class="math inline">\(a_k\)</span> will be orthogonal to it. Consider the primal / dual LPs
<span class="math display">\[
\begin{array}{ccccc}
 &amp; \text{Primal} &amp; \qquad \qquad &amp; &amp; \text{Dual}
 \\ \max\limits_x &amp; a_k^T x &amp; &amp; \min\limits_y &amp; b^T y
 \\ \text{s.t.} &amp; Ax \leq b &amp; &amp; \text{s.t.} &amp; A^Ty  = a_k
 \\ &amp; &amp; &amp; &amp; y \geq 0
\end{array}
\]</span>
The primal optimum <span class="math inline">\(x^*\)</span> will lie on the shared face between <span class="math inline">\(V_j\)</span> and <span class="math inline">\(V_k\)</span> if it exists; the dual optimum <span class="math inline">\(y_k^*\)</span> corresponding to the <span class="math inline">\(k\)</span>-th row of <span class="math inline">\(A\)</span> will be non-zero (denoting the constraint is binding) if this is the case. Thus <span class="math inline">\(DADJ_{jk} = DADJ_{kj} = 1\)</span> if the dual optimum in the above is strictly positive: <span class="math inline">\(y_k^* &gt; 0\)</span>. By convention, <span class="math inline">\(DADJ_{jk}=0\)</span> implies <span class="math inline">\(V_j\)</span> and <span class="math inline">\(V_k\)</span> are not adjacenct. Relying on symmetry, <span class="math inline">\(n_W \times (n_W -1)/2\)</span> linear programs must be constructed and solved to determine all entries of <span class="math inline">\(DADJ\)</span>. This is cumbersome but still feasible as each LP test can be performed in parallel. The Delaunay triangulation of the first-order Voronoi tessellation given above is:
<img src="figs/vor1_delaunay.png" width="70%" style="display: block; margin: auto;" /></p>
<p>Although inherently parallelizable, the computational effort required to compute the full Delaunay adjacency matrix can be quite large. As discussed above a LP must be solved for each unique pair of first-order Voronoi cells in the tessellation, which is <span class="math inline">\(\mathcal{O}(n_W^2)\)</span> separate optimizations. More, the complexity of each LP grows with the data dimension <span class="math inline">\(d\)</span>. <code>VorVQ</code> utilizes parallel computation and the <a href="https://www.gurobi.com/">Gurobi solver</a> which is, to our knowledge, <a href="https://www.gurobi.com/pdfs/benchmarks.pdf">the fastest LP solver available</a>, but the cumulative time required to compute <span class="math inline">\(DADJ\)</span> can still be improved.</p>
<p>To achieve this, <code>VorVQ</code> employs an intelligent search strategy to avoid solving the Delaunay LP for all <span class="math inline">\(n_W(n_W-1)/2\)</span> possible adjacencies. This strategy relies heavily on the Gabriel graph <span class="citation">[<a href="#ref-Gabriel1969" role="doc-biblioref">3</a>]</span> of VQ prototypes, whose adjacency matrix we denote by <span class="math inline">\(GADJ\)</span>. The Gabriel graph is another proximity graph which places an edge between vertices <span class="math inline">\(w_j\)</span> and <span class="math inline">\(w_k\)</span> IFF the ball whose diameter has endpoints <span class="math inline">\(w_j\)</span> and <span class="math inline">\(w_k\)</span> contains no other vertices <span class="math inline">\(w_l\)</span>. That is, if <span class="math inline">\(\bar{w_{jk}}\)</span> is the midpoint between <span class="math inline">\(w_j\)</span> and <span class="math inline">\(w_k\)</span>, and <span class="math inline">\(d(w_j,w_k)\)</span> is their Euclidean distance, then
<span class="math display">\[
GADJ_{jk} = \begin{cases}
1 &amp; \#\{ l \, : \, d(w_l, \bar{w_{jk}}) &lt; \frac{1}{2} d(w_j,w_k)\} = 0
\\ 0 &amp; \text{else}
\end{cases}
\]</span>
The Gabriel graph of the learned prototypes of the synthetic two-dimensional data is shown below (in orange edges), overlain on the Delaunay graph from above (in blue).<br />
<img src="figs/vor1_gabriel.png" width="70%" style="display: block; margin: auto;" />
It is clear that many, but not all, Delaunay edges exist in the Gabriel graph; what is not clear from the above, but has been proven <span class="citation">[<a href="#ref-Jaromczyk1992" role="doc-biblioref">11</a>]</span>, is that Gabriel graphs are proper sub-graphs of Delaunay graphs. Further, they are <em>guaranteed</em> to be connected. <code>VorVQ</code> exploits these two properties to effectively “seed” the Delaunay graph computation in two different ways. First, as a Delaunay sub-graph, any Gabriel edge is necessarily a Delaunay edge (so Gabriel edges do not need to be tested via the Delaunay LP). Second, as a sub-triangulation, we can intelligently focus attention on (and only test) special pairs of vertices for Delaunay adjacency. These “special pairs” are those vertices which, if connected, would help complete an existing partial triangle (simplex) in the <span class="math inline">\(GADJ\)</span>; such pairs necessarily are within geodesic distance = 2 on <span class="math inline">\(GADJ\)</span>. After identification and Delaunay testing of such pairs, this process can be repeated until there are no un-tested vertex pairs of geodesic distance = 2 in the updated <span class="math inline">\(DADJ\)</span>. Pseudo-code for this intelligent searching is given below:</p>

<p>In experiments the above algorithm has resulted in a 20-90% reduction in the computational effort expended to compute the full <span class="math inline">\(DADJ\)</span>, excluding the costing of computing the initial <span class="math inline">\(GADJ\)</span>. Luckily, the latter also has a parallel implementation in <code>VorVQ</code> making the initialization step very fast for any set of prototypes of reasonable size for a vector quantizer.</p>
</div>
<div id="secEllipsoids" class="section level2">
<h2><span class="header-section-number">1.5</span> Polytope Approximating Ellipsoids</h2>
<p>As Voronoi polytopes are often highly irregular (e.g., they have drastically varying number of faces, or no observable symmetry), a study of their geometry usually proceeds by investigating a polytope approximator. Ellipsoids are a common approximator as their geometry is well understood and their functional form easy to manipulate. <code>VorVQ</code> offers two such approximators: the <strong>Dikin</strong> ellipsoid and <strong>M</strong>aximum <strong>V</strong>olume <strong>I</strong>inscribed <strong>E</strong>llipsoid (MVIE), each denoted by <span class="math inline">\(\mathcal{E}\)</span> and defined by a center vector <span class="math inline">\(c\)</span> and a <span class="math inline">\(d \times d\)</span> rotation <span class="math inline">\(E\)</span> of the following form:
<span class="math display">\[ \mathcal{E} = \{x \, : \, (x - c)^T E^{-1} (x-c) \leq 1 \}.\]</span></p>
<div id="dikin-ellipsoids" class="section level3">
<h3><span class="header-section-number">1.5.1</span> Dikin Ellipsoids</h3>
<p>The so-called Dikin ellipsoid <span class="math inline">\(\mathcal{E}_{\mathcal{D}}\)</span>, introduced by Dikin <span class="citation">[<a href="#ref-Dikin1967" role="doc-biblioref">5</a>]</span> (in Russian) but also discussed in <span class="citation">[<a href="#ref-Boyd2004" role="doc-biblioref">1</a>]</span>, was originally put forth as a tool for an early interior point method for the solution of linear programs. Consider an arbitrary LP with objective <span class="math inline">\(g(y)\)</span> and feasible region <span class="math inline">\(P \coloneqq Ay \leq b\)</span>, where <span class="math inline">\(y \in \mathbb{R}^d\)</span>, <span class="math inline">\(A \in \mathbb{R}^{m \times d}\)</span> with rows <span class="math inline">\(a_i^T\)</span> and <span class="math inline">\(b \in \mathbb{R}^m\)</span>. At iteration <span class="math inline">\(k\)</span>, given <span class="math inline">\(y_k \in P\)</span>, the method computes the Dikin ellipsoid centered at <span class="math inline">\(y_k\)</span>, <span class="math inline">\(\mathcal{E}_{\mathcal{D}}(y_k, E_{\mathcal{D}}(y_k))\)</span>, and updates <span class="math inline">\(y_{k+1} = \arg\min\limits_{y \in \mathcal{E}_{\mathcal{D}}} g(y)\)</span> until convergence. The ellipsoidal transformation <span class="math inline">\(E_{\mathcal{D}}(y)\)</span> is given by the Hessian of the logarithmic barrier function
<span class="math display">\[
\text{barrier}(y) = -\sum\limits_{i=1}^m \log(b_i - a_i^T y)
\]</span>
which accumulates the log distances (i.e., slacks) to each of the hyperplanes defining <span class="math inline">\(P\)</span> (and we note for completeness is the objective function whose  over <span class="math inline">\(y\)</span> is the analytic center of <span class="math inline">\(P\)</span>). Thus
<span class="math display">\[
E_{\mathcal{D}}(y)
= \frac{\partial^2 \text{barrier}(y)}{\partial y^2}
= \sum\limits_{i=1}^m \left(\frac{1}{b_i - a_i^T y}\right)^2 a_i a_i^T
= A^T \, \mathrm{diag}(1 / (b - Ay))^2 \, A.
\]</span>
The Dikin ellipsoid approximates the <em>local</em> geometry of the polytope around <span class="math inline">\(y\)</span>: bounding hyperplanes that are closer to <span class="math inline">\(y\)</span> exert greater influence on its curvature and rotation than do those that are farther away. Several Dikin ellipsoids within a single first-order Voronoi cell are shown below: the blue ellipsoid is centered at the prototype generating the cell, while the teal are centered at various other points within the polytope showing how the Dikin ellipsoid conforms to local geometry.
<img src="figs/poly_dikin.png" width="70%" style="display: block; margin: auto;" /></p>
</div>
<div id="maximum-volume-inscribed-ellipsoids" class="section level3">
<h3><span class="header-section-number">1.5.2</span> Maximum Volume Inscribed Ellipsoids</h3>
<p>Predictably, the MVIE <span class="math inline">\(\mathcal{E}_{\mathcal{I}}\)</span> is <em>inscribed</em> in a polytope <span class="math inline">\(P \coloneqq Ay \leq b\)</span> with maximum volume. Determining the MVIE is not trivial, requiring sophisticated interior point methods in convex optimization. In <span class="citation">[<a href="#ref-ZhangGao2003" role="doc-biblioref">4</a>]</span>, Zhang and Gao develop a practical interior-point method for computation of MVIEs in arbitrary dimension. Beginning with any interior point <span class="math inline">\(c_{\mathcal{I}}\)</span> as initial center, the algorithm first computes the Dikin ellipsoid as an initial transformation <span class="math inline">\(E_{\mathcal{I}}\)</span>. The remaining computational effort iteratively updates <span class="math inline">\(c_{\mathcal{I}}\)</span> and <span class="math inline">\(E_{\mathcal{I}}\)</span> to maximize <code>log det</code> <span class="math inline">\(E_{\mathcal{I}}\)</span> subject to <span class="math inline">\(\mathcal{E}_{\mathcal{I}} \subset P\)</span>. Upon convergence, the optimal <span class="math inline">\(\mathcal{E}_{\mathcal{I}}\)</span> can be taken as a suitable ellipsoidal approximation of <span class="math inline">\(P\)</span>, as the MVIE shown below (in green, with starting center point in black) indicates:<br />
<img src="figs/poly_mvie.png" width="70%" style="display: block; margin: auto;" /></p>
<p><code>VorVQ</code> computes the MVIEs for all cells in the (first or second-order) Voronoi tessellation using a version of <a href="https://www.caam.rice.edu/~zhang/mve/">Zhang’s code</a> translated to C++ from Matlab and adapted for parallel implementation.</p>

</div>
</div>
</div>
<h3>References</h3>
<div id="refs" class="references">
<div id="ref-Boyd2004">
<p>[1] S. Boyd, S. P. Boyd, and L. Vandenberghe, <em>Convex optimization</em>. Cambridge university press, 2004.</p>
</div>
<div id="ref-Delaunay1934">
<p>[2] B. Delaunay and others, “Sur la sphere vide,” <em>Izv. Akad. Nauk SSSR, Otdelenie Matematicheskii i Estestvennyka Nauk</em>, vol. 7, nos. 793-800, pp. 1–2, 1934.</p>
</div>
<div id="ref-Gabriel1969">
<p>[3] K. R. Gabriel and R. R. Sokal, “A new statistical approach to geographic variation analysis,” <em>Systematic Zoology</em>, vol. 18, no. 3, pp. 259–278, 1969.</p>
</div>
<div id="ref-ZhangGao2003">
<p>[4] Y. Zhang and L. Gao, “On numerical solution of the maximum volume ellipsoid problem,” <em>SIAM Journal on Optimization</em>, vol. 14, no. 1, pp. 53–76, 2003.</p>
</div>
<div id="ref-Dikin1967">
<p>[5] I. Dikin, “Iterative solution of problems of linear and quadratic programming,” in <em>Doklady akademii nauk</em>, 1967, vol. 174, pp. 747–748.</p>
</div>
<div id="ref-Gray1984">
<p>[6] R. Gray, “Vector quantization,” <em>IEEE ASSP Magazine</em>, vol. 1, no. 2, pp. 4–29, 1984.</p>
</div>
<div id="ref-AtsuyukiEtAl2000">
<p>[7] A. Okabe, B. Boots, K. Sugihara, and S. N. Chiu, <em>Spatial tessellations: Concepts and applications of voronoi diagrams</em>. Wiley, 2000.</p>
</div>
<div id="ref-MartinetzSchulten1994">
<p>[8] T. Martinetz and K. Schulten, “Topology representing networks,” <em>Neural Networks</em>, vol. 7, no. 3, pp. 507–522, 1994.</p>
</div>
<div id="ref-TasdemirMerenyi2009">
<p>[9] K. Taşdemir and E. Merényi, “Exploiting data topology in visualization and clustering of self-organizing maps,” <em>IEEE Transactions on Neural Networks</em>, vol. 20, no. 4, pp. 549–562, 2009.</p>
</div>
<div id="ref-Agrell1993">
<p>[10] E. Agrell, “A method for examining vector quantizer structures,” in <em>Proceedings. IEEE international symposium on information theory</em>, 1993, pp. 394–394.</p>
</div>
<div id="ref-Jaromczyk1992">
<p>[11] J. W. Jaromczyk and G. T. Toussaint, “Relative neighborhood graphs and their relatives,” <em>Proceedings of the IEEE</em>, vol. 80, no. 9, pp. 1502–1517, 1992.</p>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="index.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="secInstallation.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": ["VorVQ.README.pdf"],
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
